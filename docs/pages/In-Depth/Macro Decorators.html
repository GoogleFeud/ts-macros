<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="keywords" content="typescript, documentation, docs, ts, ts-macros"><title>Macro Decorators | ts-macros</title><meta name="description" content="Typescript API documentation for ts-macros v2.1.0"><link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"><link id="highlightTheme" rel="stylesheet" crossorigin="anonymous"><link rel="icon" type="image/x-icon" href="/assets/media/favicon.ico"><link href="../../assets/css/index.css" type="text/css" rel="stylesheet"><script>window.depth="../../";window.ab=false;</script><script src="../../assets/js/index.js"></script></head><body><header class="container-fluid navi"><div class="row"><div class="col-4"><input class="form-control search" id="search" type="search" placeholder="Search..." aria-label="Search"></div><div class="col-8"><div class="row float-end row-cols-auto" style="margin-top:5px"><div class="col clickable-icon" id="theme-icon"></div><div class="col"><a href="https://github.com/GoogleFeud/ts-macros/tree/HEAD" class="clickable-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-github" viewbox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></a></div><div class="col"><span style="font-size: 1.2em">v2.1.0</span></div></div></div></div></header><div class="container-fluid"><div class="row"><nav class="col-lg-auto sidebar" id="sidebar"><h1 class="lib-name text-center"><a href="../../index.html">ts-macros</a></h1><p class="current-thing text-center"></p><div class="sidebar-members"><div class="sidebar-member"><div class="collapsible-trigger"><span class="collapsible-arrow open"></span><span class="sidebar-category">In-Depth</span></div><div class="collapsible-body open"><span class="sidebar-category-member"><a href="../In-Depth/Overview.html">Overview</a></span><span class="sidebar-category-member"><a href="../In-Depth/Chaining Macros.html">Chaining Macros</a></span><span class="sidebar-category-member"><a href="../In-Depth/Expanding macros.html">Expanding macros</a></span><span class="sidebar-category-member"><a href="../In-Depth/Parameters.html">Parameters</a></span><span class="sidebar-category-member"><a href="../In-Depth/Repetitions.html">Repetitions</a></span><span class="sidebar-category-member"><a href="../In-Depth/Literals.html">Literals</a></span><span class="sidebar-category-member"><a href="../In-Depth/Markers.html">Markers</a></span><span class="sidebar-category-member"><a href="../In-Depth/Built-in macros.html">Built-in macros</a></span><span class="sidebar-category-member"><span><a href="../In-Depth/Macro Decorators.html" style="font-weight: bold">Macro Decorators</a><div style="padding-left:15px"><a href="#decorator-composition" class="sidebar-category-member">Decorator composition</a><a href="#more-info-and-tips" class="sidebar-category-member">More info and tips</a></div></span></span><span class="sidebar-category-member"><a href="../In-Depth/Macro labels.html">Macro labels</a></span></div></div><div class="sidebar-member"><div class="collapsible-trigger"><span class="collapsible-arrow open"></span><span class="sidebar-category">Links</span></div><div class="collapsible-body open"><span class="sidebar-category-member"><a href="https://googlefeud.github.io/ts-macros/playground/" target="_blank"><span style="position: relative; top: -2.25px; right: 3px;"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-box-arrow-up-left" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M7.364 3.5a.5.5 0 0 1 .5-.5H14.5A1.5 1.5 0 0 1 16 4.5v10a1.5 1.5 0 0 1-1.5 1.5h-10A1.5 1.5 0 0 1 3 14.5V7.864a.5.5 0 1 1 1 0V14.5a.5.5 0 0 0 .5.5h10a.5.5 0 0 0 .5-.5v-10a.5.5 0 0 0-.5-.5H7.864a.5.5 0 0 1-.5-.5z"></path><path fill-rule="evenodd" d="M0 .5A.5.5 0 0 1 .5 0h5a.5.5 0 0 1 0 1H1.707l8.147 8.146a.5.5 0 0 1-.708.708L1 1.707V5.5a.5.5 0 0 1-1 0v-5z"></path></svg></span>Playground</a></span></div></div></div></nav><main id="content" class="col content"><div class="d-none" id="search-menu"><h1>Search results</h1><div class="row" style="margin-top: 20px;margin-bottom: 20px"><div class="col-md-4"><p class="mini-header">Types</p><div><input type="checkbox" class="c-checkbox" id="search-option-classes" checked><span>Classes</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-interfaces" checked><span>Interfaces</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-enums" checked><span>Enums</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-functions" checked><span>Functions</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-types" checked><span>Type aliases</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-constants"><span>Constants</span></div></div><div class="col-md-4"><p class="mini-header">Members</p><div><div><input type="checkbox" class="c-checkbox" id="search-option-properties" checked><span>Properties</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-methods" checked><span>Methods</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-getters" checked><span>Getters</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-setters" checked><span>Setters</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-enum-members"><span>Enum members</span></div><div><input type="checkbox" class="c-checkbox" id="search-option-privates"><span>Show privates</span></div></div></div><div class="col-md-4"><p class="mini-header">Other</p><div><div><input type="checkbox" class="c-checkbox" id="search-option-this-module-only"><span>In this module only</span></div></div></div></div><div id="search-result-list"></div></div><div id="content-main" class="d-none"><div class="path"><span><a href="../../index.html" class="path-member">index</a> / <span class="path-member">In-Depth</span> / <a href="" class="path-member">Macro Decorators</a></span></div><h1 id="macro-decorators" class="section-header">Macro decorators</h1><p>Macro functions can also be used as decorators! Here is a basic macro which adds two numbers, let&#39;s try using it as a decorator:</p>
<div class="tab-code"><span class="tab-code-tab hljs">Macro</span><span class="tab-code-tab hljs">Call</span><span class="tab-code-tab hljs">Result</span><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">$add</span>(<span class="hljs-params">numA: <span class="hljs-built_in">number</span>, numB: <span class="hljs-built_in">number</span></span>) : <span><span class="c-tooltip"><a class="reference-link object" href="../../type/EmptyDecorator.html">EmptyDecorator</a><span class="c-tooltip-content"><span class="keyword">type </span><span class="item-name object">EmptyDecorator</span><span style="display:block" class="monospace fw-bold"><span class="item-name object">EmptyDecorator</span></span></span></span></span> {
    <span class="hljs-keyword">return</span> (numA + numB) <span class="hljs-keyword">as</span> unknown <span class="hljs-keyword">as</span> <span><span class="c-tooltip"><a class="reference-link object" href="../../type/EmptyDecorator.html">EmptyDecorator</a><span class="c-tooltip-content"><span class="keyword">type </span><span class="item-name object">EmptyDecorator</span><span style="display:block" class="monospace fw-bold"><span class="item-name object">EmptyDecorator</span></span></span></span></span>;
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-meta">@$add</span>!(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">class</span> Test {}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs">(<span class="hljs-number">3</span>)</code></pre></div></div><p>The macro expands and replaces the entire class declaration. Since macros are just plain functions, they cannot get access to the class itself and manipulate it. This is why for decorator macros to work, we need to use the <span><span class="c-tooltip"><a class="reference-link method-name" href="../../function/$$raw.html">$$raw</a><span class="c-tooltip-content"><span class="keyword">function </span><span class="item-name method-name">$$raw</span><span style="display:block" class="monospace fw-bold"><span class="item-name method-name">$$raw</span></span></span></span></span> built-in macro, which allows us to manipulate the typescript AST directly!</p>
<p>Let&#39;s write a macro which creates a copy of the class, except with a name of our choosing. With the <code>$$raw</code> macro, we get access to the class AST node thanks to the <code>ctx</code> object:</p>
<pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">$renameClass</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) : <span><span class="c-tooltip"><a class="reference-link object" href="../../type/EmptyDecorator.html">EmptyDecorator</a><span class="c-tooltip-content"><span class="keyword">type </span><span class="item-name object">EmptyDecorator</span><span style="display:block" class="monospace fw-bold"><span class="item-name object">EmptyDecorator</span></span></span></span></span> {
    <span class="hljs-keyword">return</span> $$raw!(<span class="hljs-function">(<span class="hljs-params">ctx, newNameNode: ts.StringLiteral</span>) =&gt;</span> {
       <span class="hljs-keyword">const</span> target = ctx.<span class="hljs-property">thisMacro</span>.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> ts.<span class="hljs-property">ClassDeclaration</span>;
    });
}</code></pre><p>To copy the class, we can use the <code>ctx.factory.updateClassDeclaration</code> method:</p>
<pre><code class="hljs">ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">updateClassDeclaration</span>(
    target,
    target.<span class="hljs-property">modifiers</span>?.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">kind</span> !== ctx.<span class="hljs-property">ts</span>.<span class="hljs-property">SyntaxKind</span>.<span class="hljs-property">Decorator</span>),
    ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">createIdentifier</span>(newNameNode.<span class="hljs-property">text</span>),
    target.<span class="hljs-property">typeParameters</span>,
    target.<span class="hljs-property">heritageClauses</span>,
    target.<span class="hljs-property">members</span>
)</code></pre><p>It&#39;s important to remove the decorators from the declaration so the macro decorators don&#39;t get to the compiled code. Let&#39;s put it all together:</p>
<div class="tab-code"><span class="tab-code-tab hljs">Macro</span><span class="tab-code-tab hljs">Call</span><span class="tab-code-tab hljs">Result</span><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">$renameClass</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) : <span><span class="c-tooltip"><a class="reference-link object" href="../../type/EmptyDecorator.html">EmptyDecorator</a><span class="c-tooltip-content"><span class="keyword">type </span><span class="item-name object">EmptyDecorator</span><span style="display:block" class="monospace fw-bold"><span class="item-name object">EmptyDecorator</span></span></span></span></span> {
    <span class="hljs-keyword">return</span> $$raw!(<span class="hljs-function">(<span class="hljs-params">ctx, newNameNode: ts.StringLiteral</span>) =&gt;</span> {
       <span class="hljs-keyword">const</span> target = ctx.<span class="hljs-property">thisMacro</span>.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> ts.<span class="hljs-property">ClassDeclaration</span>;
       <span class="hljs-keyword">return</span> ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">updateClassDeclaration</span>(
            target,
            target.<span class="hljs-property">modifiers</span>?.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">kind</span> !== ctx.<span class="hljs-property">ts</span>.<span class="hljs-property">SyntaxKind</span>.<span class="hljs-property">Decorator</span>),
            ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">createIdentifier</span>(newNameNode.<span class="hljs-property">text</span>),
            target.<span class="hljs-property">typeParameters</span>,
            target.<span class="hljs-property">heritageClauses</span>,
            target.<span class="hljs-property">members</span>
        )
    });
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-meta">@$renameClass</span>!(<span class="hljs-string">&quot;NewTest&quot;</span>)
<span class="hljs-keyword">class</span> Test {
    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">class</span> NewTest {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a, b</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }
}</code></pre></div></div><p>Multiple decorators can be applied to a declaration, so let&#39;s create another macro which adds a method which desplays all the properties of the class. I know this looks like a lot of code, but over 50% of the lines are just updating and creating the AST declarations:</p>
<div class="tab-code"><span class="tab-code-tab hljs">Macro</span><span class="tab-code-tab hljs">Call</span><span class="tab-code-tab hljs">Result</span><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">$addDebugMethod</span>(<span class="hljs-params"></span>) : <span><span class="c-tooltip"><a class="reference-link object" href="../../type/EmptyDecorator.html">EmptyDecorator</a><span class="c-tooltip-content"><span class="keyword">type </span><span class="item-name object">EmptyDecorator</span><span style="display:block" class="monospace fw-bold"><span class="item-name object">EmptyDecorator</span></span></span></span></span> {
    <span class="hljs-keyword">return</span> $$raw!(<span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> target = ctx.<span class="hljs-property">thisMacro</span>.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> ts.<span class="hljs-property">ClassDeclaration</span>;
        <span class="hljs-keyword">return</span> ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">updateClassDeclaration</span>(
            target,
            target.<span class="hljs-property">modifiers</span>?.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">kind</span> !== ctx.<span class="hljs-property">ts</span>.<span class="hljs-property">SyntaxKind</span>.<span class="hljs-property">Decorator</span>),
            target.<span class="hljs-property">name</span>,
            target.<span class="hljs-property">typeParameters</span>,
            target.<span class="hljs-property">heritageClauses</span>,
            [
                ...target.<span class="hljs-property">members</span>,
                ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">createMethodDeclaration</span>(
                    <span class="hljs-literal">undefined</span>,
                    <span class="hljs-literal">undefined</span>,
                    <span class="hljs-string">&quot;debug&quot;</span>,
                    <span class="hljs-literal">undefined</span>,
                    <span class="hljs-literal">undefined</span>,
                    [],
                    <span class="hljs-literal">undefined</span>,
                    ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">createBlock</span>(ctx.<span class="hljs-property">transformer</span>.<span class="hljs-title function_">strToAST</span>(<span class="hljs-string">`
                        console.log(
                            &quot;<span class="hljs-subst">${target.name?.getText()}</span> &quot;, &quot;{\\n&quot;,
                                <span class="hljs-subst">${target.members.filter(m =&gt; ctx.ts.isPropertyDeclaration(m) &amp;&amp; ctx.ts.isIdentifier(m.name)).map(m =&gt; <span class="hljs-string">`&quot;<span class="hljs-subst">${(m.name <span class="hljs-keyword">as</span> ts.Identifier).text}</span>: &quot;, this.<span class="hljs-subst">${(m.name <span class="hljs-keyword">as</span> ts.Identifier).text}</span>}`</span>).join(<span class="hljs-string">&quot;,\&quot;\\n\&quot;,&quot;</span>)}</span>,
                            &quot;\\n}&quot;
                        )
                    `</span>))
                )
            ]
        )
    });
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-meta">@$renameClass</span>!(<span class="hljs-string">&quot;NewTest&quot;</span>)
<span class="hljs-meta">@$addDebugMethod</span>!()
<span class="hljs-keyword">class</span> Test {
    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">class</span> NewTest {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a, b</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }
    <span class="hljs-title function_">debug</span>(<span class="hljs-params"></span>) { 
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Test &quot;</span>, <span class="hljs-string">&quot;{\n&quot;</span>, <span class="hljs-string">&quot;propA: &quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;propB: &quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span>, <span class="hljs-string">&quot;\n}&quot;</span>); 
    }
}</code></pre></div></div><p>Here we use the strToAST method to make writing the AST easier - the method transforms a string to an array of statements. We can also use it to create the entire class AST, but then you&#39;ll have to stringify the class&#39; type parameters, constructor, other members, etc. so it becomes even more messy.</p>
<p>To allow flexibility, decorator macros can return <strong>an array of declarations</strong> so they not only edit declarations, but also create new ones as well. Here&#39;s a macro which copies a method, but logs it&#39;s arguments in the body:</p>
<div class="tab-code"><span class="tab-code-tab hljs">Macro</span><span class="tab-code-tab hljs">Call</span><span class="tab-code-tab hljs">Result</span><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">copyMethod</span>(<span class="hljs-params">ctx: RawContext, original: ts.MethodDeclaration, name?: <span class="hljs-built_in">string</span>, body?: ts.Block</span>): ts.<span class="hljs-property">MethodDeclaration</span> {
    <span class="hljs-keyword">return</span> ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">updateMethodDeclaration</span>(
        original,
        original.<span class="hljs-property">modifiers</span>?.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">kind</span> !== ctx.<span class="hljs-property">ts</span>.<span class="hljs-property">SyntaxKind</span>.<span class="hljs-property">Decorator</span>),
        original.<span class="hljs-property">asteriskToken</span>,
        name ? ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">createIdentifier</span>(name) : original.<span class="hljs-property">name</span>,
        original.<span class="hljs-property">questionToken</span>,
        original.<span class="hljs-property">typeParameters</span>,
        original.<span class="hljs-property">parameters</span>,
        original.<span class="hljs-property">type</span>,
        body || original.<span class="hljs-property">body</span>
    )
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">$logArgs</span>(<span class="hljs-params"></span>): <span><span class="c-tooltip"><a class="reference-link object" href="../../type/EmptyDecorator.html">EmptyDecorator</a><span class="c-tooltip-content"><span class="keyword">type </span><span class="item-name object">EmptyDecorator</span><span style="display:block" class="monospace fw-bold"><span class="item-name object">EmptyDecorator</span></span></span></span></span> {
    <span class="hljs-keyword">return</span> $$raw!(<span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> target = ctx.<span class="hljs-property">thisMacro</span>.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> ts.<span class="hljs-property">MethodDeclaration</span>;
        <span class="hljs-keyword">return</span> [
            <span class="hljs-comment">// Same method, we just remove the decorators</span>
            <span class="hljs-title function_">copyMethod</span>(ctx, target),
            <span class="hljs-comment">// Test method which logs the arguments</span>
            <span class="hljs-title function_">copyMethod</span>(ctx, target,
                (target.<span class="hljs-property">name</span> <span class="hljs-keyword">as</span> ts.<span class="hljs-property">Identifier</span>).<span class="hljs-property">text</span> + <span class="hljs-string">&quot;Test&quot;</span>,
                ctx.<span class="hljs-property">factory</span>.<span class="hljs-title function_">createBlock</span>([
                    ...ctx.<span class="hljs-property">transformer</span>.<span class="hljs-title function_">strToAST</span>(
                        <span class="hljs-string">`console.log(<span class="hljs-subst">${target.parameters.filter(p =&gt; ctx.ts.isIdentifier(p.name)).map(p =&gt; (p.name <span class="hljs-keyword">as</span> ts.Identifier).text).join(<span class="hljs-string">&quot;,&quot;</span>)}</span>)`</span>
                    ),
                    ...(target.<span class="hljs-property">body</span>?.<span class="hljs-property">statements</span> || [])
                ])
            )
        ]
    });
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-meta">@$renameClass</span>!(<span class="hljs-string">&quot;NewTest&quot;</span>)
<span class="hljs-meta">@$addDebugMethod</span>!()
<span class="hljs-keyword">class</span> Test {
    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }

    <span class="hljs-meta">@$logArgs</span>!()
    <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-keyword">return</span> a + b;
    }
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">class</span> NewTest {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a, b</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }
    <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
        <span class="hljs-keyword">return</span> a + b;
    }
    <span class="hljs-title function_">addTest</span>(<span class="hljs-params">a, b</span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-keyword">return</span> a + b; }
    <span class="hljs-title function_">debug</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Test &quot;</span>, <span class="hljs-string">&quot;{\n&quot;</span>, <span class="hljs-string">&quot;propA: &quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;propB: &quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span>, <span class="hljs-string">&quot;\n}&quot;</span>); }
}</code></pre></div></div><h2 id="decorator-composition" class="section-header">Decorator composition</h2><p>Decorators are called bottom-to-top, so in the example above, <code>$addDebugMethod</code> is called first, then <code>$renameClass</code>. However, what happens when a decorator macro returns an array of declarations? Let&#39;s try it out by creating another decorator which renames a method:</p>
<div class="tab-code"><span class="tab-code-tab hljs">Macro</span><span class="tab-code-tab hljs">Call</span><span class="tab-code-tab hljs">Result</span><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">function</span> <span class="hljs-title function_">$renameMethod</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>) : <span><span class="c-tooltip"><a class="reference-link object" href="../../type/EmptyDecorator.html">EmptyDecorator</a><span class="c-tooltip-content"><span class="keyword">type </span><span class="item-name object">EmptyDecorator</span><span style="display:block" class="monospace fw-bold"><span class="item-name object">EmptyDecorator</span></span></span></span></span> {
    <span class="hljs-keyword">return</span> $$raw!(<span class="hljs-function">(<span class="hljs-params">ctx, newNameNode: ts.StringLiteral</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> target = ctx.<span class="hljs-property">thisMacro</span>.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> ts.<span class="hljs-property">MethodDeclaration</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">copyMethod</span>(ctx, target, newNameNode.<span class="hljs-property">text</span>);
    });
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-meta">@$renameClass</span>!(<span class="hljs-string">&quot;NewTest&quot;</span>)
<span class="hljs-meta">@$addDebugMethod</span>!()
<span class="hljs-keyword">class</span> Test {
    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }

    <span class="hljs-meta">@$renameMethod</span>!(<span class="hljs-string">&quot;addNums&quot;</span>)
    <span class="hljs-meta">@$logArgs</span>!()
    <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-keyword">return</span> a + b;
    }
}</code></pre></div><div class="tab-code-code" style="display: none"><pre><code class="hljs"><span class="hljs-keyword">class</span> NewTest {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a, b</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }
    <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
        <span class="hljs-keyword">return</span> a + b;
    }
    <span class="hljs-title function_">addNums</span>(<span class="hljs-params">a, b</span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a, b); <span class="hljs-keyword">return</span> a + b; }
    <span class="hljs-title function_">debug</span>(<span class="hljs-params"></span>) { <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Test &quot;</span>, <span class="hljs-string">&quot;{\n&quot;</span>, <span class="hljs-string">&quot;propA: &quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span>, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;propB: &quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span>, <span class="hljs-string">&quot;\n}&quot;</span>); }
}</code></pre></div></div><p>First <code>logArgs</code> gets the declaration and instead of it returns two new ones: <code>add</code> (which happens to be the old declaration) and <code>addTest</code>. Then <code>renameMethod</code> gets it&#39;s hands on <strong>only the last returned method</strong> from the previous decorator, which is <code>addTest</code>, so it renames it to <code>addNums</code>.</p>
<p>To make this work, we&#39;ll have to switch the orders of the decorators:</p>
<pre><code class="hljs"><span class="hljs-meta">@$renameClass</span>!(<span class="hljs-string">&quot;NewTest&quot;</span>)
<span class="hljs-meta">@$addDebugMethod</span>!()
<span class="hljs-keyword">class</span> Test {
    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span>
    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">string</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propA</span> = a;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">propB</span> = b;
    }

    <span class="hljs-meta">@$logArgs</span>!()
    <span class="hljs-meta">@$renameMethod</span>!(<span class="hljs-string">&quot;addNums&quot;</span>)
    <span class="hljs-title function_">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">string</span></span>) {
        <span class="hljs-keyword">return</span> a + b;
    }
}</code></pre><h2 id="more-info-and-tips" class="section-header">More info and tips</h2><ul>
<li>You can also use decorator macros on methods, accessors, properties and parameters.</li>
<li>Returning <code>undefined</code> in the <span><span class="c-tooltip"><a class="reference-link method-name" href="../../function/$$raw.html">$$raw</a><span class="c-tooltip-content"><span class="keyword">function </span><span class="item-name method-name">$$raw</span><span style="display:block" class="monospace fw-bold"><span class="item-name method-name">$$raw</span></span></span></span></span> macro callback will erase the decorator target.</li>
<li>The declaration returned by the <span><span class="c-tooltip"><a class="reference-link method-name" href="../../function/$$raw.html">$$raw</a><span class="c-tooltip-content"><span class="keyword">function </span><span class="item-name method-name">$$raw</span><span style="display:block" class="monospace fw-bold"><span class="item-name method-name">$$raw</span></span></span></span></span> callback goes through the transformer, so macros can be called inside it!</li>
<li>Always use the methods from <code>ctx.ts</code> and <code>ctx.factory</code>, <strong>not</strong> from <code>ts</code> and <code>ts.factory</code>.</li>
<li>If you get an <code>Invalid Arguments</code> error, that means that some node does not match the expected one by typescript, for example, you cannot give a call expression node to a method name.</li>
<li>Do <strong>not</strong> use the <code>getText</code> method if you&#39;re going to have multiple decorator macros on the same declaration. All but the bottom macros are going to receive synthetic nodes, not real nodes, and the <code>getText</code> method does not work for synthetic nodes. It&#39;s best to avoid it if you want to be able to reuse macros.</li>
</ul>
</div></main></div></div><div id="to-top" class="btn-to-top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-arrow-up" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M8 15a.5.5 0 0 0 .5-.5V2.707l3.146 3.147a.5.5 0 0 0 .708-.708l-4-4a.5.5 0 0 0-.708 0l-4 4a.5.5 0 1 0 .708.708L7.5 2.707V14.5a.5.5 0 0 0 .5.5z"></path></svg></div><div id="sidebar-arrow" class="sidebar-arrow"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-arrow-right" viewbox="0 0 16 16"><path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"></path></svg></div></body></html>